$Header: /repo/public.cvs/app/BioGate/BioMooCore/core122.moo,v 1.1 2021/07/27 06:44:27 bruce Exp $

>@dump #122 with create
@create $thing named Generic Gopher Slate:Generic Gopher Slate,ggs
@prop #122."value" {} r
;;#122.("value") = {"81848	guest	bridges.ee.usm.maine.edu	1848", "8Angreal MOO	guest	aura-philips.com	9999", "8ArcticMOO	Guest	caxy.lfa.lfc.edu	8888", "8AussieMOO	guest	silo.riv.csu.edu.au	7777", "8BayMOO	guest	baymoo.sfsu.edu	8888	+", "8Chiba-Sprawl	guest	chiba.picosof.com	7777	+", "8CowsGoMOO	guest	stoopid.res.wpi.edu	1234", "8Cybersphere	guest	cs.vv.com	7777", "8Dhalgren	guest	actinic.princeton.edu	7777	+", "8Diversity University	connect guest guest	moo.du.org	8888	+", "8DragonsFire	guest guest	moo.eskimo.com	7777	+", "8DreaMOO	guest, no pw	fiinix.metronet.com	8888", "8Dysfunctional Family MOO	co guest	moo.fly.net	7777", "8ForestMOO	guest	avatar.phys-plant.utoledo.edu	8888", "8GamesMOO	connect Guest	stcm.com	7777", "8GhostWheel	co guest	casper.bga.com	6969", "8GopherMOO	connect Guest	reality.cs.umn.edu	6464", "8Harper's Tale MOO	guest guest	mserv1.wizvax.net	5000", "8HoloMOO	guest	shu.isisnet.com	6666", "8Imagination	guest	mud.achilles.net	8888", "8Immaterial Park MOO	co guest	sun1.gwent.ac.uk	7777", "8Kingdom MOO	guest	frosted.mhv.net	6969", "8LakeMoo	guest guest	carbon.cudenver.edu	7777", "8LambdaMOO	guest	lambda.parc.xerox.com	8888	+", "8Logos		logos.daedalus.com	8888", "8MOOhalo	Guest	lei.net	9000", "8MOOtiny	con Guest	spsyc.nott.ac.uk	8888", "8MUSE USMEE	guest	muse.ee.usm.maine.edu	23", "8Meadow		meadow.greenwing.com	7777", "8MetaVerse	guest with no password	multiverse.io.com	7777	+", "8Moo 2000		sunlab.npac.syr.edu	2000", "8MundoHispano	guest (no password needed)	io.syr.edu	8888", "8NecroMOO	connect guest	sirill.svg.mbs.no	7777", "8OmegaMOO	connect Guest	hades.inlink.com	5000", "8Panda	guest	panda.gatech.edu	1234	+", "8Point MOOt	connect Tourist	ok.rtf.utexas.edu	8888	+", "8PulpMOO	Co Guest	jupiter.di.uminho.pt	7777", "8RiverMOO	co guest	river.honors.indiana.edu	8888", "8Schoolnet Moo		schoolnet.ingenia.com	7777", "8Snow	Guest	ginger.lei.net	9030", "8StMOO	guest	aaraaf.ravenet.com	1701", "8StarWarsMOO	connect guest	bast.isisnet.com	7777", "8TechMOOseum	guest	whyanext.com	8888	+", "8TrekMOO	co guest [no password]	shu.isisnet.com	1701", "8USMEE		micro.usmee.maine.edu	0", "8UltiMOO	Guest	sydney.sensemedia.net	2001", "8Valhalla	connect Guest	VALHALLA.ACUSD.EDU	4444	+", "8Virtual Pern	guest	dragon.clawpaw.com	9999", "8WeyrmountMOO	Guest	lei.net	9020"}
@prop #122."stack" {} r
;;#122.("stack") = {{"spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO", "1MOO", 21}, {"spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links", "1Links to MUDs via Telnet", 21}, {"spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs", "1MUDs"}, {"spinaltap.micro.umn.edu", 70, "1/fun/Games", "1Games"}, {"spinaltap.micro.umn.edu", 70, "1/fun", "1Fun & Games"}, {"gopher.micro.umn.edu", 70, "", "1University of Minnesota Gopher menu"}}
@prop #122."busy" 0 r
@prop #122."remembered" {} r
;;#122.("remembered") = {"1The University of Illinois Weather Machine		wx.atmos.uiuc.edu	70", "1Lyrics directory	1/pub/music/lyrics	cs.uwp.edu	70", "1Electronic Frontier Foundation archives		gopher.eff.org	70", "1Movie reviews	1/fun/Movies	ashpool.micro.umn.edu	70", "1lambda gopher server		lambda.parc.xerox.com	4000", "1University of Minnesota Gopher menu		gopher.micro.umn.edu	70", "1Internet scavenger hunt	1/hunt	gopher.cic.net	70", "1parcftp.xerox.com MOO FTP area	ftp:parcftp.xerox.com@/pub/MOO/	gopher.stanford.edu	70", "1Search the Internet (Veronica and more from NYSERNET)	1/Search the Internet	nysernet.org	70", "1Papers by F. Randall Farmer on Cyberspace (anon FTP)	ftp:netcom.com@/pub/electric/	gopher.stanford.edu	70"}
@prop #122."desclines" {} r
;;#122.("desclines") = {"1. 1848 (telnet)", "2. Angreal MOO (telnet)", "3. ArcticMOO (telnet)", "4. AussieMOO (telnet)", "5. BayMOO (telnet)", "6. Chiba-Sprawl (telnet)", "7. CowsGoMOO (telnet)", "8. Cybersphere (telnet)", "9. Dhalgren (telnet)", "10. Diversity University (telnet)", "11. DragonsFire (telnet)", "12. DreaMOO (telnet)", "13. Dysfunctional Family MOO (telnet)", "14. ForestMOO (telnet)", "15. GamesMOO (telnet)", "16. GhostWheel (telnet)", "17. GopherMOO (telnet)", "18. Harper's Tale MOO (telnet)", "19. HoloMOO (telnet)", "20. Imagination (telnet)", "21. Immaterial Park MOO (telnet)", "22. Kingdom MOO (telnet)", "23. LakeMoo (telnet)", "24. LambdaMOO (telnet)", "25. Logos (telnet)", "26. MOOhalo (telnet)", "27. MOOtiny (telnet)", "28. MUSE USMEE (telnet)", "29. Meadow (telnet)", "30. MetaVerse (telnet)", "31. Moo 2000 (telnet)", "32. MundoHispano (telnet)", "33. NecroMOO (telnet)", "34. OmegaMOO (telnet)", "35. Panda (telnet)", "36. Point MOOt (telnet)", "37. PulpMOO (telnet)", "38. RiverMOO (telnet)", "39. Schoolnet Moo (telnet)", "40. Snow (telnet)", "41. StMOO (telnet)", "42. StarWarsMOO (telnet)", "43. TechMOOseum (telnet)", "44. TrekMOO (telnet)", "45. USMEE (telnet)", "46. UltiMOO (telnet)", "47. Valhalla (telnet)", "48. Virtual Pern (telnet)", "49. WeyrmountMOO (telnet)"}
@prop #122."seen" {} r
;;#122.("seen") = {{#87867}, {#87867, "gopher.micro.umn.edu", 70, ""}, {#87867, "spinaltap.micro.umn.edu", 70, "1/fun"}, {#87867, "spinaltap.micro.umn.edu", 70, "1/fun/Games"}, {#87867, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs"}, {#87867, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links"}, {#87867, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO"}, {#102850, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO"}, {#107783, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO"}, {#109344, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO"}, {#108653, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO"}, {#109030, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO"}, {#112855, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO"}, {#108455, "spinaltap.micro.umn.edu", 70, "1/fun/Games/MUDs/Links/MOO"}}
@prop #122."length" 20 rc
@prop #122."help_msg" {} rc
;;#122.("help_msg") = {"Moving around:", " pick <item> on <slate>", "    select the given menu item (either a number or partial name).", "    If it is a text item, it will show it to you.", " <number> on <slate>", "    e.g., 12 on slate. You can omit `pick' when chosing items", "    by their number.", " back <slate> [for n]", "    go back up a level; with n supplied, goes back n levels", " reset <slate>", "    reset slate to the default list of `remember'-ed nodes", " goto host [port [path]] on <slate>", "    make a direct jump to a specified host. Please be careful --", "    at the moment this slows everyone down if the host isn't valid.", "", "Controlling noise:", " ignore <slate>", "    stop listening when other people fiddle with the slate", " watch <slate>", "    start watching while other people fiddle with the slate", " show <slate> to <player>", "    show the contents of the slate to someone even if they're not watching", "", "Modifying the `reset' list:", " remember [<item>] on <slate>", "    adds item to the list you get when you `reset' slate", "    will prompt you for title", " remember on <slate>", "    remembers the current menu choice rather than any ", "    particular item", " forget <item> on <slate>", "    (Only when the slate is `reset')", "    deletes the given item", "", "In long menus and text:", " next [<n>] on <slate>", " prev [<n>] on <slate>", "    move you forward/backward in the set of visible menu items.", "    You can give a `number of pages' to move forward.", " read <slate>", "    show you the entire contents of the slate", " read <item> on <slate>", "    if <item> is a text menu, it will show the text without", "    actually changing the state of the slate.", "", "Miscellaneous:", " stack <slate>", "    show stack, where `back' will go", " details <item> on <slate>", "    show host, port number, and selection string for a given item.    ", " mailme <slate>", "    if you have a valid registration address: send mail with the", "    slate contents to your email address.", " mailme <item> on <slate>", "    this will mail you the <item>, if it is text.", "", "When you first make a gopher slate, you will need to use `goto'", "and then `remember' to set up the default list of nodes."}
@prop #122."locked" 0 r
@prop #122."ignoring" {} r
@prop #122."watching" {} r
;;#122.("watching") = {#87867}
@prop #122."controlled" #-1 r
@prop #122."work_with_msg" "%N starts to work with %t." rc
;;#122.("aliases") = {"Generic Gopher Slate", "ggs"}
;;#122.("description") = "A laptop size computer, with various controls on it."
;;#122.("object_size") = {0, 0}
;;#122.("icon") = "http://hppsda.mayfield.hp.com/image/gopher_slate.gif"
;;#122.("vrml_coords") = {{-3006, -537, -2562}, {0, 0, 0}, {1000, 1000, 1000}}
;;#122.("vrml_desc") = {"Transform {scaleFactor .25 .25 .25}", "Material {diffuseColor .4 .4 .4}", "WWWInline {name \"http://hppsda.mayfield.hp.com/image/monitor1.wrl\"}"}

@verb #122:"p*ick" any on this rxd
@program #122:pick
"pick <entry> on slate";
"  entry is either a line number or an initial substring of a line description";
"  select that entry: if it is a menu, go to that node. If it is a search,";
"  asks you for the search term & does the search.";
"  Some kinds of nodes are not implemented.";
if (this:_textp() || (!(this.stack || this.remembered)))
  return player:tell("There's nothing to pick.");
endif
if (this:busy("picking"))
  return;
endif
if (!(which = this:match_choice(dobjstr)))
  "match_choice took care of it.";
  this:busy(0);
  return;
endif
if ((tostr(tonum(dobjstr)) == dobjstr) && (!({player, @this:_place()} in this.seen)))
  player:tell($string_utils:pronoun_sub("Oooops, perhaps you should look at the %t first."));
  this:busy(0);
  return;
endif
parse = $gopher:parse(this.value[which]);
desc = this.desclines[which];
this:announce_op("%N %<picks> '", desc, "' on the %t.");
this:do_pick(@parse);
return;
.

@verb #122:"reset" this none none rxd
@program #122:reset
"reset slate";
"  reset the slate to its set of 'remembered' selections";
if (why = this:is_locked(player))
  return player:tell($string_utils:pronoun_sub("Sorry, %t seems to be "), why, ".");
elseif (this:busy("resetting"))
  return;
endif
this:announce_op("%N %<resets> the %t.");
this.seen = {};
this:set_pointer();
this:busy(0);
.

@verb #122:"pop back" any any any rxd
@program #122:pop
"back this [by <n>]";
"  move back up the gopher stack to the previous menu";
"  or previous N menus.";
n = 1;
if (iobjstr && (!(iobjstr == tostr(n = tonum(iobjstr)))))
  return player:tell("Sorry, '", iobjstr, "' doesn't look like a number.");
endif
if (length(this.stack) < n)
  player:tell("Sorry, there aren't ", n, " levels to go back.");
  return;
endif
if (this:busy("going back"))
  return;
endif
this:announce_op("%N %<goes> back up ", (n == 1) ? "a level" | tostr(n, " levels"), " on the %t.");
this:set_pointer(@this.stack[n + 1..length(this.stack)]);
this:busy(0);
.

@verb #122:"location_string" this none this rx
@program #122:location_string
"location_string([location])";
"A nice-looking version of the location provided, or current location.";
loc = (args && args[1]) || this.stack[1];
where = loc[1];
if (st = loc[4])
  "human readable string";
  return ((st[2..length(st)] + " (from ") + where) + ")";
  return (where + ": ") + st[2..length(st)];
endif
if (loc[3])
  return ((loc[3] + " (from ") + where) + ")";
  return (where + ": ") + loc[3];
endif
return where;
.

@verb #122:"stack" this none none rxd
@program #122:stack
"stack slate";
"  show a summary of the gopher stack";
max = 0;
if (!this.stack)
  return player:tell($string_utils:pronoun_sub("%T is at the top level."));
endif
for x in (this.stack)
  max = max(max, length(x[1]));
endfor
max = max + 6;
for x in ($list_utils:reverse(this.stack))
  summary = $gopher:summary(x);
  player:tell($string_utils:left(summary[1], max), " ", summary[2]);
endfor
.

@verb #122:"busy" this none this
@program #122:busy
"interlock for caching -- mark cache busy or clear; return true if interlock failed";
if (!args[1])
  this.busy = 0;
  return 0;
endif
if ((args[1] != "reading") && (why = this:is_locked(player)))
  player:tell($string_utils:pronoun_sub("Sorry, %t seems to be "), why, ".");
  return 1;
endif
"make player running this watch it.";
this.watching = setadd(this.watching, player);
"set busy";
if (this.busy && $code_utils:task_valid(this.busy[4]))
  if (this.busy[1] > time())
    player:tell("***Sorry, ", this.name, " is busy ", this.busy[2], " for ", this.busy[3], " -- wait a bit.");
    return 1;
  endif
  player:tell("*** ", this.name, " was ", this.busy[2], " for ", this.busy[3], " but it timed out.");
  kill_task(this.busy[4]);
endif
this.busy = {time() + (60 * 3), args[1], player.name, task_id()};
return 0;
.

@verb #122:"match_choice" this none this
@program #122:match_choice
"match_choice(input string)";
"returns the index of the choice, or 0.";
"is noisy.";
if (this:_textp())
  player:tell($string_utils:pronoun_sub("%T is looking at a text node and has no choices."));
  return 0;
endif
input = args[1];
which = $code_utils:tonum(input);
len = length(value = this.value);
if (typeof(which) == NUM)
  if ((which < 1) || (which > len))
    player:tell("Sorry, ", input, " isn't a number between 1 and ", len, ".");
    return 0;
  endif
  return which;
else
  exact = partial = {};
  for choice in [1..len]
    valchoice = value[choice][2..index(value[choice], "	") - 1];
    if (input == valchoice)
      exact = {@exact, choice};
    elseif (index(valchoice, input) == 1)
      partial = {@partial, choice};
    endif
  endfor
  if (length(exact) > 1)
    player:tell("I'm not sure whether you meant ", $string_utils:english_list(exact, "", " or "), ".");
    return 0;
  elseif (exact)
    return exact[1];
  elseif (length(partial) > 1)
    player:tell("I'm not sure whether you meant ", $string_utils:english_list(partial, "", " or "), ".");
    return 0;
  elseif (partial)
    return partial[1];
  else
    player:tell("Sorry, there is no choice named ", $string_utils:print(input), ".");
    return 0;
  endif
endif
.

@verb #122:"jump goto" any on this rxd
@program #122:jump
"goto <host> [socket [path]] on slate";
"  given an explicit host name and optional socket, attempt to open a";
"  gopher connection to that socket";
words = $string_utils:words(dobjstr);
if (!words)
  player:tell("Usage:  ", verb, " <host> [socket]", prepstr ? tostr(" on ", iobjstr) | "");
  return;
endif
host = words[1];
socket = 70;
if (length(words) > 1)
  socket = tonum(words[2]);
  if (socket < 3)
    player:tell("The value '", words[2], "' is not a valid socket.");
    return;
  endif
endif
path = "";
type = "1<jump>";
if (length(words) > 2)
  path = dobjstr[(index(dobjstr, words[2]) + length(words[2])) + 1..length(dobjstr)];
  type = "0<jump>";
endif
if (this:busy(tostr("jumping to ", host, " socket ", socket)))
  return;
endif
this:announce_op(tostr("%N %<jumps> to ", host, " socket ", socket, path ? " " | "", path, " on the %t."));
parse = {host, socket, path, type};
this:set_pointer(parse, @this:_textp() ? listdelete(this.stack, 1) | this.stack);
this:busy(0);
.

@verb #122:"details" any on this rxd
@program #122:details
if (!(which = this:match_choice(dobjstr)))
  "match_choice took care of it.";
  return;
endif
parse = $gopher:parse(this.value[which]);
sel = parse[4];
if (sel)
  for x in ({"Type=" + sel[1], "Name=" + sel[2..length(sel)], "Path=" + parse[3], "Host=" + parse[1], "Port=" + tostr(parse[2]), "#"})
    player:tell(x);
  endfor
else
  player:tell("**** ERROR, ", which, " is not a valid entry.");
endif
.

@verb #122:"set_pointer" this none this rx
@program #122:set_pointer
if (!args)
  value = this.remembered;
else
  value = $gopher:get(@args[1]);
endif
if (!value)
  this:busy(0);
  this:announce_op($gopher:interpret_error(value));
  return 0;
endif
if (value[1][1] == "3")
  this:busy(0);
  this:announce_op("The gopher request results in an error:");
  for x in (value)
    this:announce_op(": ", x ? x[2..length(x)] | x);
  endfor
  return 0;
endif
if (args && (args[1][4][1] == "0"))
  "text node";
  desc = value;
else
  desc = this:menu_choices(value);
endif
$command_utils:suspend_if_needed(0);
this.desclines = desc;
this.stack = args;
this.value = value;
this:busy(0);
this:show_results();
return 1;
.

@verb #122:"do_pick" this none this
@program #122:do_pick
"do_pick(host, port, path, string) -- take parsed output & interact with user as appropriate.";
string = args[4];
if ((!string) || index("1?", type = string[1]))
  "menu";
  this:set_pointer(args, @this.stack);
elseif (type == "7")
  player:tell("Search for what? Enter search line or @abort:");
  search = read();
  if (search != "@abort")
    this:announce_op("%N %<searches> for ", search, " on %t.");
    this:set_pointer({args[1], args[2], (args[3] + "	") + search, args[4]}, @this.stack);
  else
    this:busy(0);
    this:announce_op("%N %<decides> not to search.");
  endif
elseif (type == "3")
  this:busy(0);
  this:announce_op("%N chose an error line.");
elseif (type == "0")
  "slates can point at text nodes";
  this:set_pointer(args, @this.stack);
elseif (type == "2")
  search = $command_utils:read("one of 'name=<name>' 'phone=<phone>' 'email=<email>'");
  if (!match(search, "[a-z]+=[a-z0-9@-]+"))
    this:busy(0);
    player:tell((search == "@abort") ? "No search." | ("Invalid query: " + search));
    return;
  endif
  this:announce_op("%N %<searches> for ", search, " on %t.");
  this:set_pointer({args[1], args[2], (args[3] + "	query ") + search, args[4]}, @this.stack);
elseif ($object_utils:has_property(player, "gopher_local") && player.gopher_local)
  this:busy(0);
  notify(player, tostr("#$# gopher	", args[1], "	", args[2], "	", args[4], "	", args[3]));
else
  this:busy(0);
  this:announce_op("Type ", type, " (", $gopher:type(type), ") gopher requests not implemented.");
  if (type == "8")
    player:tell("**** telnet ", args[1], (args[2] in {23, 0}) ? "" | (" " + tostr(args[2])));
    if (args[3])
      player:tell("     log in as: ", args[3]);
    endif
  endif
endif
.

@verb #122:"remember" any on this rxd
@program #122:remember
"remember <entry/here> on <this>";
"  add the entry (or this menu) to the 'remembered set' for this room.";
"  use 'remembered' to retrieve the set.";
if (!this.stack)
  return player:tell("Sorry, remembering remembered nodes doesn't work.");
endif
if (dobjstr == "")
  parse = this.stack[1];
  desc = "the current menu";
elseif (choice = this:match_choice(dobjstr))
  parse = $gopher:parse(this.value[choice]);
  desc = this.desclines[choice];
else
  "Match_choice took care of it.";
  return;
endif
parse[4] = parse[4][1] + $command_utils:read("description for " + desc);
this.remembered = {@this.remembered, $gopher:unparse(@parse)};
this:announce_op("%N %<remembers> ", desc, " on the %t as ", parse[4][2..length(parse[4])], ".");
.

@verb #122:"forget delete" any on this rxd
@program #122:forget
"forget <entry> on slate";
"  erase an entry from the 'remembered set'";
"  only works if you're looking at the 'remembered set'";
if (this.stack)
  player:tell("You're not looking at the top.");
  return;
endif
if (!(choice = this:match_choice(dobjstr)))
  return;
endif
this:announce_op("%N %<forgets> '", this.desclines[choice], "' on the %t.");
this.remembered = listdelete(this.remembered, choice);
this:set_pointer();
.

@verb #122:"look_self" this none this
@program #122:look_self
if (this.stack)
  sum = $gopher:summary(this.stack[1]);
  player:tell(this:titlec(), ": ", sum[1], " ", sum[2]);
else
  player:tell(this:titlec());
endif
player:tell_lines(this:description());
this:_tell_desc();
state = "";
if (valid(this.controlled))
  state = ($string_utils:pronoun_sub("The %t is being controlled by ") + this.controlled:title()) + ".";
endif
if ((busy = this:_is_busy()) || state)
  player:tell(state ? state + " " | "", busy ? $string_utils:pronoun_sub(tostr("The %t is busy ", this.busy[2], " for ", this.busy[3], ".")) | "");
endif
.

@verb #122:"_tell_desc" this none this
@program #122:_tell_desc
who = args ? args[1] | player;
plen = (length(args) > 1) ? args[2] | this.length;
header = (length(args) > 2) && args[3];
if (this:_textp())
  text = this:text();
  len = length(text);
  if ((!plen) || (len <= plen))
    $command_utils:suspend_if_needed(0);
    "6/24/93 change tell_lines to notify_lines to reduce lag.";
    if (header)
      who:tell("--------------- ", this.name, "-----");
      who:notify_lines(text);
      who:tell("--------------- ", this.name, "-----");
    else
      who:notify_lines(text);
    endif
    return;
  endif
  offset = this:offset();
  npages = (len / plen) + 1;
  thispage = (offset / plen) + 1;
  if ((offset != 1) || header)
    who:tell("--", thispage, " of ", npages, "----- 'prev on ", this.name, "' for previous----");
  endif
  end = (offset + plen) - 1;
  who:tell_lines(text[offset..min(len, end)]);
  if ((len > end) || header)
    who:tell("--", thispage, " of ", npages, "----- 'next on ", this.name, "' for more --------");
  endif
  return;
endif
this.seen = setadd(this.seen, {who, @this:_place()});
len = length(this.desclines);
if (header)
  who:tell("--------------- ", this.name, "-----");
endif
if (plen && (len > plen))
  offset = this:offset();
  who:tell_lines(this.desclines[offset..min((offset + this.length) - 1, len)]);
  nxt = "next on " + this.name;
  prv = "previous on " + this.name;
  who:tell("---- '", (offset == 1) ? nxt | (((offset + plen) > len) ? prv | (((("'" + nxt) + "' or '") + prv) + "'")), "' to see additional choices (", len, " total) ---");
else
  who:tell_lines(this.desclines || {$string_utils:pronoun_sub("%T is empty right now.")});
  if (header)
    who:tell("--------------- ", this.name, "-----");
  endif
endif
.

@verb #122:"next prev*ious" any on this rxd
@program #122:next
if (this:busy("reading"))
  "can't 'next' if it is busy";
  return;
endif
this:busy(0);
n = tonum(dobjstr) || 1;
if (verb != "next")
  n = -n;
  verb = "previous";
endif
offset = this:offset();
new = offset + (n * this.length);
if (new < 1)
  if (offset == 1)
    return player:tell("You're already at the beginning.");
  else
    new = 1;
  endif
elseif (new > length(this.desclines))
  return player:tell("You're already at the end.");
endif
this:announce_op("%N %<looks> at the ", verb, " ", this:_textp() ? "page" | "results", " on the %t.");
this:offset(new);
this:show_results();
.

@verb #122:"initialize" this none this
@program #122:initialize
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
  "don't call this unless you mean it.";
  this.seen = {};
  this.desclines = {};
  "The default is that slate's inherit the 'remembered' from their parent. This means, though, that they're initially blank but have to be 'reset' to fire up. See :do_reset";
  "this.remembered = {}";
  this.busy = 0;
  this.stack = {};
  this.watching = {};
  this.controlled = #-1;
  pass(@args);
  this.desclines = this:menu_choices(this.value = this.remembered);
endif
.

@verb #122:"announce_op" this none this
@program #122:announce_op
msg = tostr(@args);
player:tell($string_utils:pronoun_sub(msg, $you));
if (this.location != player)
  this.location:announce($string_utils:pronoun_sub(msg));
endif
return;
"announcing only to watching";
if (watching = setremove($set_utils:intersection(this.watching, this.location:contents()), player))
  msg = $string_utils:pronoun_sub(msg);
  for x in (watching)
    x:tell(msg);
  endfor
endif
.

@verb #122:"_place" this none this
@program #122:_place
return this.stack && this.stack[1][1..3];
.

@verb #122:"_textp" this none this
@program #122:_textp
return this.stack && index("02", this.stack[1][4][1]);
.

@verb #122:"r*ead" any any any rxd
@program #122:read
if ((!argstr) || ((dobj == this) && (!prepstr)))
  this:_tell_desc(player, 0);
elseif (which = this:match_choice((($code_utils:short_prep(prepstr) == "on") && (iobj == this)) ? dobjstr | argstr))
  where = $gopher:parse(this.value[which]);
  if (index("02", where[4][1]))
    this:announce_op("%N %<reads> '", this.desclines[which], "' on the %t.");
    $gopher:show_text(player, 0, 0, @where);
    player:tell("-------");
  else
    player:tell("Item '", this.desclines[which], "' isn't text and can't be read.");
  endif
else
  player:tell("Read what?");
endif
.

@verb #122:"lock unlock" this none none rxd
@program #122:lock
this.locked = verb == "lock";
this:announce_op("%N %<", $string_utils:lowercase(verb), "s> %t.");
.

@verb #122:"text" this none this
@program #122:text
return this.value;
"don't update slates";
.

@verb #122:"update" this none none rxd
@program #122:update
if (this:busy("updating", 1))
  return;
endif
this:announce_op("%N %<updates> %t.");
if (this.stack)
  $gopher:clear_cache(@this.stack[1]);
endif
this:set_pointer(@this.stack);
.

@verb #122:"_mail_text" this none this
@program #122:_mail_text
if (this:_textp())
  return this.value;
else
  text = {};
  for x in (this.value)
    parse = $gopher:parse(x);
    sel = parse[4];
    text = {@text, "Type=" + sel[1], "Name=" + sel[2..length(sel)], "Path=" + parse[3], "Host=" + parse[1], "Port=" + tostr(parse[2]), "#"};
  endfor
  return text;
endif
.

@verb #122:"show_results" this none this
@program #122:show_results
"after a selection is made, this verb is used to show the results; usually to 'player'";
inhere = $object_utils:isa(this.location, $room) ? this.location:contents() | {player};
for x in (this.watching = setadd(this.watching, player))
  $command_utils:suspend_if_needed(0);
  if (x in inhere)
    this:_tell_desc(x, this.length, player != x);
  else
    this.watching = setremove(this.watching, x);
  endif
endfor
.

@verb #122:"ignore watch" this none none rxd
@program #122:ignore
was = player in this.watching;
this.watching = (verb == "watch") ? setadd(this.watching, player) | setremove(this.watching, player);
is = player in this.watching;
if (was == is)
  player:tell("You already were ", (verb == "watch") ? "watching" | "ignoring", " ", this:title(), ".");
elseif (this.location == player)
  player:tell("You start to ", verb, " ", this:title(), ".");
else
  $you:say_action(("%N %<starts> to " + verb) + " %t.");
endif
.

@verb #122:"show" this to any rxd
@program #122:show
if (!valid(iobj))
  return player:tell("I don't see '", iobjstr, "' here.");
endif
$you:say_action("%N %<shows> %t to %i.");
this:_tell_desc(iobj, this.length, 1);
.

@verb #122:"_is_busy" this none this
@program #122:_is_busy
if (this.busy)
  if (this.busy[1] > time())
    return 1;
  else
    this.busy = 0;
  endif
endif
return 0;
.

@verb #122:"control" this none none rxd
@program #122:control
if (this.controlled == player)
  player:tell("You are already controlling ", this:title(), ".");
  return;
endif
from = valid(this.controlled) ? (" from " + this.controlled:title()) + "." | ".";
if (this.location != player)
  this.location:announce_all_but({player}, $string_utils:pronoun_sub("%N takes the controls of %t"), from);
endif
player:tell("You take the controls of ", this:title(), from);
this.controlled = player;
.

@verb #122:"release" this none none rxd
@program #122:release
if (this.controlled == player)
  $you:say_action("%N %<releases> the controls of %t.");
  this.controlled = #-1;
else
  player:tell("You weren't holding the controls of ", this.name, ".");
endif
.

@verb #122:"is_locked" this none this
@program #122:is_locked
"is this locked?";
if (this.locked)
  return "locked";
elseif (valid(this.controlled) && (this.controlled != args[1]))
  if (this.location in {this.controlled, this.controlled.location})
    return "controlled by " + this.controlled.name;
  else
    this.controlled = #-1;
  endif
endif
return 0;
.

@verb #122:"match_command" this none this rx
@program #122:match_command
"match_command(vrb, dlist, plist, ilist)";
"return true if this object can handle the command, false otherwise";
"vrb - name of the verb the player typed";
"dlist - list of objspecs that this command matches";
"plist and ilist - likewise for prepspecs, iobjspecs";
if ((player.focus_object == this) && (this.location in {player, player.location}))
  vrb = args[1];
  dlist = args[2];
  plist = args[3];
  ilist = args[4];
  if (((vrb in {"pick", "jump", "goto", "details", "remember", "forget", "delete", "next", "prev", "previ", "previo", "previou", "previous"}) && ("none" in plist)) && ("none" in ilist))
    return 1;
  elseif (((vrb in {"read", "ignore", "watch"}) && ("none" in dlist)) && ("none" in plist))
    return 1;
  elseif (((vrb in {"show"}) && ("none" in dlist)) && ("at/to" in plist))
    return 1;
  elseif ((vrb in {"reset", "stack", "mailme", "lock", "unlock", "update", "control", "release"}) && (!("on top of/on/onto/upon" in plist)))
    return 1;
  elseif (((vrb in {"pop", "back"}) && ("none" in dlist)) && (("none" in plist) || ("for/about" in plist)))
    return 1;
  endif
endif
return pass(@args);
.

@verb #122:"work" none with this r
@program #122:work
"This is a JaysHouseMOO verb -- probably doesn't work on other MOOs without a 'focus' object.";
if (valid(player:set_focus_object(this)))
  $you:say_action(this.work_with_msg);
else
  player:tell("You just can't seem to focus on that.");
endif
.

@verb #122:"mailme" any any any rxd
@program #122:mailme
"mailme note";
if ((caller_perms() != player) && (caller != player))
  return player:tell("Someone tried to mail you some text, but it didn't work.");
endif
if (!player.email_address)
  return player:tell("Sorry, you don't have a registered email address.");
endif
if ((!argstr) || ((dobj == this) && (!prepstr)))
  where = this.stack[1];
elseif (which = this:match_choice((($code_utils:short_prep(prepstr) == "on") && (iobj == this)) ? dobjstr | argstr))
  where = $gopher:parse(this.value[which]);
endif
if (where)
  player:tell("Mailing ", this:location_string(where), " to ", player.email_address, ".");
  text = $gopher:_mail_text(where);
  player:tell("... ", length(text), " lines ...");
  text = {tostr("(Mail initiated by ", player.name, " (", player, ") connected from ", $string_utils:connection_hostname(connection_name(player)), " using ", this.name, ")"), @text};
  suspend(0);
  result = $network:sendmail(player.email_address, this:location_string(where), @text);
  if (result == 0)
    player:tell("Mail sent successfully.");
  else
    player:tell("Mail sending error: ", result, ".");
  endif
else
  player:tell("Sorry, can't mail this.");
endif
.

@verb #122:"header" this none this
@program #122:header
"used by _tell_desc for prefix & suffix lines";
args[1]:tell("------- ", $string_utils:left($string_utils:pronoun_sub(tostr(@listdelete(args, 1), " ")), args[1]:linelen(), "-"));
.

@verb #122:"offset" this none this
@program #122:offset
if (!this.stack)
  return 1;
endif
menu = this.stack[1];
if (args)
  if (length(menu) > 4)
    this.stack[1][5] = args[1];
  else
    this.stack[1] = {@{@menu, "", "", "", ""}[1..4], args[1]};
  endif
elseif (length(menu) > 4)
  return menu[5];
else
  return 1;
endif
.

@verb #122:"<select>" none on this
@verb #122:"menu_choices" this none this
@program #122:menu_choices
desc = {};
cnt = 1;
for x in (args[1])
  $command_utils:suspend_if_needed(0);
  type = $gopher:type(x[1]);
  if (type == "text")
    type = "";
  else
    type = (" (" + type) + ")";
  endif
  tab = index(x, "	");
  label = x[2..tab - 1];
  desc = {@desc, tostr(cnt, ". ", label, type)};
  cnt = cnt + 1;
endfor
return desc;
.

@verb #122:"find" any on this rxd
@program #122:find
if (this:busy("finding"))
  "can't 'next' if it is busy";
  return;
endif
this:busy(0);
offset = this:offset();
words = $string_utils:words(dobjstr);
if ((length(words) == 2) && (words[1] == "page"))
  if (((page = tonum(words[2])) < 1) || (((page - 1) * this.length) > length(this.desclines)))
    return player:tell("Sorry, `", words[2], "' doesn't look like a page number on ", this.name, ".");
  endif
  this:announce_op("%N %<finds> page ", page, " on the %t.");
else
  if (!(page = this:findpage(dobjstr)))
    return player:tell("Sorry, no further page of ", this.name, " contains `", dobjstr, "'.");
  endif
  this:announce_op("%N %<finds> `", dobjstr, "' on the %t.");
endif
this:offset((page - 1) * this.length);
this:show_results();
.

@verb #122:"findpage" this none this
@program #122:findpage
":findpage(string)  which page of the text this slate is looking for contains `string'";
"return page number or 0";
offset = this:offset();
len = this.length;
lines = this.desclines;
for i in [offset + len..length(lines)]
  if (index(lines[i], args[1]))
    return i / len;
  endif
endfor
return 0;
.

@verb #122:"more_info_for_web" this none this rx #95
@program #122:more_info_for_web
"more_info_for_web( ) -> HTML doc LIST";
"Returns the hyperlinked HTML doc equivalent to whatever's";
"currently being displayed on the gopher slate.";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
text = {"<P><B>The gopher-slate's menu displays:</B>", "<UL>"};
if (this:_textp())
  text = {@text, "<PRE>", this.desclines, "</PRE>"};
else
  for i in [1..length(this.value)]
    value = $gopher:parse(this.value[i]);
    line = tostr("<LI><A HREF=\"", this:url_for(i), "\" TARGET=\"accessory_frame\">", tostr(i), ")</A> ", value[4][2..length(value[4])], "<BR>");
    text = {@text, line};
  endfor
endif
return {@text, "</UL>"};
"Last modified Fri Aug 16 02:35:05 1996 IDT by EricM (#3264).";
.

@verb #122:"url_for" this none this rx #95
@program #122:url_for
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
which = args[1];
((seconds_left() < 2) || (ticks_left() < 4000)) ? $command_utils:suspend_if_needed(1) | 0;
parse = $gopher:parse(this.value[which]);
sel = parse[4];
if (sel)
  subs = match(parse[3], "%(%w*:%)%(.*%)%(:%w*%|%)@%(.*%)");
  if (!subs)
    if (sub2 = match(parse[3], "%<%(0/%)%(.*%)"))
      path = substitute("00/%2", sub2);
    elseif (sub2 = match(parse[3], "%<%(1/%)%(.*%)"))
      path = substitute("11/%2", sub2);
    else
      path = parse[3];
    endif
    url = (((("gopher://" + parse[1]) + ":") + tostr(parse[2])) + "/") + path;
  else
    path = substitute("%4", subs);
    url = (("ftp://" + strsub(substitute("%2", subs), substitute("%1", subs), "")) + ((subs[3][3][1] < subs[3][3][2]) ? ":" + substitute("%3", subs) | "")) + path;
  endif
  return url;
else
  return "";
endif
"Last modified Fri Aug 16 02:29:11 1996 IDT by EricM (#3264).";
.

"***finished***
