$Header: /repo/public.cvs/app/BioGate/BioMooCore/core118.moo,v 1.1 2021/07/27 06:44:27 bruce Exp $

>@dump #118 with create
@create $webapp named Object Browser/Editor:Object Browser/Editor,obe
@prop #118."raw_prop_edit_instructions" {} r #95
;;#118.("raw_prop_edit_instructions") = {"<B>Warning:</B> Do not use this form unless you're pretty sure you", "know what you're doing.  You can foul up an object to the extent of", "having to either recycle it or finding an administrator who might (or", "might not) be able to repair it for you.<P>", "That having been said, you can use this form to edit properties on an", "object you own.  Each property has an entry of two lines.  The second", "line is simply the value of the property.  The first line presents", "(in order): a checkbox for marking the property as edited, the name", "of the property in bold, a checkbox indicating if the property is", "\"clear\", and a set of buttons indicating the property value's", "\"type.\"<P>", "To edit a property, mark the left-most checkbox for that property,", "then change the associated buttons or fields as appropriate.  When a", "property on an object is set \"clear,\" it has the value of the", "property of the same name on the parent of the object.  If the", "\"clear\" checkbox is marked, the \"type\" and \"value\" fields are", "ignored, since the property will inherit these from the property of", "the same name on the object's parent."}
@prop #118."help_msg" {} rc
;;#118.("help_msg") = {"This object is a tool for browsing and editing objects via the web.", "It's present browsing features allow users to examine common", "properties of objects, as well as the details of properties and verbs", "on them. It is a webapp, with the webcode of 'objbrowser'.", "  It's editing features include editing common features, and editing", "all +c properties on objects. The common feature editing system works", "in conjunction with #1:object_edit_for_web, and", "#1:edit_object_by_web, and verbs of the same name on child objects.", "The first verb generates object-specific forms for editing aspects of", "the object, and the latter processes the information generated by the", "form, updating the object appropriately.", "  The basic page produced by this webapp (when nothing but", "MOO/xx/objbrowser is provided) is generated by :basic_webedit_form().", "This includes fields for selecting an object and specifying what the", "user wants (ie. browse, edit...).", "", "Browse", "", "  Object browsing requests are handled by :show_for_web(), which", "produces the basic browsing page for an object.  That verb includes a", "call to :get_verbs_for_web(), which produces the 'obvious verbs' list", "for the page.  Selecting the 'kids list' on that page causes a call", "to :showkids_for_web, generating a page listing the kids of the", "object.  The kids on the list are hyperlinked to call the", ":showkids_for_web with THAT object as the target.  The basic object", "browsing page also include a link for seeing the help text for the", "object, which calls :object_help() to generate the appropriate page.", "Finally, you can browse properties and verbs by selecting the", "appropriate link on the basic object browsing page.  The resulting", "page is generated by :browse_details(), on which the verb names are", "hyperlinked.  Those links allow you to list the verb code, a page", "generated by :browse_verb().", "", "Editing", "", "  The two object editing system supported at this time are intended", "for builders.  One allows builders to customize their objects for the", "most common aspects, including description, aliases, message texts,", "and others.  It also includes fields for editing the objects", "associated URL (for pictures), or HTML page.  The Object", "Browser/Editor doesn't do any of the actual work for this.  It's", ":provide_post() just calls the :object_edit_for_web() verb on the", "object, and that verb generates the appropriate editing form.  The", "object's :object_edit_for_web() verb performs a pass() to collect the", "forms for all parent you update a section, the object passes the form", "data down to the appropriate parent object;s #1:edit_object_by_web", "verb, which knows how to process that form and update the appropriate", "characters.  This is explained in more detail in the comments at the", "head of the #1:#1:edit_object_by_web and #1:object_edit_for_web", "verbs.", "  The Object Browser/Editor also support editing of the full set of", "+c properties on object, by the object's owner.  The appropriate form", "is generated by and processed by :edit_raw_props().  It can handle", "property values of any type except for nested lists.  This could be", "implemented with an appropriate parsing algorithm, but I haven't done", "it yet.", "", "Programming", "", "  There are appropriate hooks in the :provide_post() verb to support", "programmer features, which are planned."}
;;#118.("code") = "objbrowser"
;;#118.("available") = 1
;;#118.("aliases") = {"Object Browser/Editor", "obe"}
;;#118.("description") = {"  This object is a web application that handles object browsing and editing."}
;;#118.("object_size") = {48443, 937987203}
;;#118.("web_calls") = 578

@verb #118:"showkids_for_web" this none this rxd #95
@program #118:showkids_for_web
"Generates the web page showing a list of kids for args[1], each a hyperlink.";
"Actually, this verb just calls this:generate_display_list to provide";
"the actual list, and simply packages that list with a header.";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
what = args[1];
info = {"<H1>Object Browser and Editor</H1>"};
info = {@info, ((("<H2>List of child objects for <A HREF=\"&LOCAL_LINK;/objbrowser/browse_or_edit/browse/" + tostr(tonum(what))) + "\">") + what:name(1)) + "</A></H2>"};
info = {@info, @this:generate_display_list(children(what))};
return info;
"Last modified Sun Jun 25 07:46:23 1995 IDT by EricM (#3264).";
.

@verb #118:"show_for_web" this none this rx #95
@program #118:show_for_web
"Generates a web page for object browsing; args[1] specifies the object.";
"Includes appropriate links to other objects' browsing pages.";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
object = args[1];
prefix = tostr("<A HREF=\"&LOCAL_LINK;/", code = this:get_code(), "/browse_or_edit/");
browser_code = $object_browser.code;
"Allow if either byte_based_quota and permitted OR object_based_quota and permitted";
"note that this just controls display of the button and the real creation is";
"controlled at $recyler:_create where it should be";
"If $quota_utils exists then the MOO is using byte based quota, else check the persons ownership_quota property.";
perms = caller_perms();
create_ok = $quota_utils:creation_permitted(perms) || ((typeof(oq = perms.ownership_quota) == NUM) && (oq > 0));
set_task_perms(perms);
controls = $perm_utils:controls(perms, object);
info = {((("<H2>" + object:namec(1)) + " [") + tostr(object)) + "]</H2>"};
if (url = object:get_url())
  info = {@info, "<HR>"};
  info = {@info, @(typeof(url) == STR) ? $web_utils:build_MIME(url) | url};
  info = {@info, "<HR>"};
endif
info = {@info, ("<P><B>Aliases</B>: " + $string_utils:english_list(object.aliases)) + ".<BR>"};
info = {@info, ((((("<B>Owned by</B>: <A HREF=\"&LOCAL_LINK;/info/" + tostr(tonum(object.owner))) + "/info\">") + object.owner:name()) + "</A> [") + tostr(object.owner)) + "]<BR>"};
if ($recycler:valid(p = parent(object)))
  info = {@info, tostr("<B>Parent object</B>: ", prefix, "browse/", tonum(p), "\">", p:name(), "</A> [", p, "]<BR>")};
else
  info = {@info, "<B>Parent</B>: [none]<BR>"};
endif
if (kids = length(children(object)))
  info = {@info, ((((("<B>Is the parent of</B>: " + prefix) + "showkids/") + tostr(tonum(object))) + "\">") + tostr(kids)) + " objects</A><BR>"};
else
  info = {@info, "<B>Is the parent of</B>: 0 objects<BR>"};
endif
"check if it's corified";
"tell object perms";
if (object.r)
  info = {@info, tostr("<B>Permissions:</B> readable, ", object.f ? "" | "not ", "fertile, and ", object.w ? "" | "not ", "writable<BR>")};
else
  info = {@info, "<B>Permissions:</B> not readable<BR>"};
endif
coreprops = properties(#0);
not_found = 1;
while (not_found && coreprops)
  if (#0.(coreprops[1]) == object)
    info = {@info, ("<B>Corified as:</B> $" + coreprops[1]) + "<BR>"};
    not_found = 0;
  endif
  coreprops = listdelete(coreprops, 1);
endwhile
if ($quota_utils.byte_based)
  info = {@info, tostr("<B>Size in bytes:</B> ", object.object_size[1], "<BR>")};
endif
"Take advantage of !d to omit the next two lines if E_PERM";
(typeof(props = properties(object)) == ERR) ? "" | (info = {@info, ("<B>Number of properties</B>: " + tostr(length(props))) + "<BR>"});
(typeof(verbs = verbs(object)) == ERR) ? "" | (info = {@info, ("<B>Number of verbs</B>: " + tostr(length(verbs))) + "<BR>"});
if (!$recycler:valid(loc = object.location))
  info = {@info, tostr("<B>Location:</B> Nowhere [#-1]<BR>")};
else
  info = {@info, tostr("<B>Location:</B> ", prefix, "browse/", tonum(loc), "\">", loc:name(), "</A> [", loc, "]<BR>")};
endif
"build hyperlinked contents list";
if (contents = object.contents)
  prefix2 = prefix + "browse/";
  lastonestr = tostr(prefix2, tonum(contents[1]), "\"> ", contents[1].name, "</A>");
  lastonestr = (contents = listdelete(contents, 1)) ? " and" + lastonestr | lastonestr;
  contentstr = "";
  contlist = {};
  while (contents)
    if ((seconds_left() < 2) || (ticks_left() < 4000))
      contlist = {@contlist, contstr, tostr(" ... (", length(contents), " items omitted) ...")};
      contents = {};
      contstr = "";
    else
      contentstr = tostr(contentstr, prefix2, tonum(contents[1]), "\"> ", contents[1].name, "</A>,");
      if (length(contentstr) > 100)
        contlist = {@contlist, contentstr};
        contentstr = "";
      endif
      contents = listdelete(contents, 1);
    endif
  endwhile
  $command_utils:suspend_if_needed(1);
  contlist = {@contlist, contentstr + lastonestr};
else
  contlist = {" (none)"};
endif
info = {@info, "<B>Contents:</B> ", @contlist, "<P>"};
if (icon = object:get_icon())
  info = {@info, ("<B>Icon</B>: <IMAGE SRC=\"" + icon) + "\"><P>"};
endif
info = {@info, "<B>Description</B>:<BR><BLOCKQUOTE>"};
desc = object:description() || {"- no description set -"};
info = {@info, @(typeof(desc) == LIST) ? desc | {desc}, "</BLOCKQUOTE>"};
if (v = this:get_verbs_for_web(object))
  info = {@info, "<B>Obvious verbs</B>:<P><BLOCKQUOTE>", @$web_utils:add_linebreaks(v), "</BLOCKQUOTE>"};
endif
objname = object:name(1);
if (object.r || controls)
  info = {@info, tostr("<P>", prefix, "browse_details/", tonum(object), "\">Browse details of properties and verbs for ", objname, "</A><BR>")};
endif
if (object:help_msg() || object.help_msg)
  info = {@info, tostr("<A HREF=\"&LOCAL_LINK;/objbrowser/browse_or_edit/showhelp/", tonum(object), "\">Read help text for ", objname, "</A>")};
endif
if (controls)
  info = {@info, tostr("<FORM METHOD=\"POST\" ACTION=\"&LOCAL_LINK;/", this:get_code(), "/", tonum(object), "\"><INPUT TYPE=\"HIDDEN\" NAME=\"action\" VALUE=\"edit_object\"><INPUT TYPE=\"HIDDEN\" NAME=\"objnumber\" VALUE=\"", tonum(object), "\"><INPUT TYPE=\"SUBMIT\" VALUE=\"Edit characteristics of ", object.name, "\"></FORM>")};
endif
"";
"test if user can create a child of object, and if so, offer form";
if (((controls || object.f) && ($object_utils:isa(perms, $builder) && perms.builder)) && create_ok)
  "user is a builder and controls the object";
  "fields: createobject=objnumber, action=create, name=name/alias expression";
  info = {@info, tostr("<P><HR><FORM METHOD=\"POST\" ACTION=\"&LOCAL_LINK;/", browser_code, "/browse_or_edit/create/", tonum(object), "\"><INPUT TYPE=\"SUBMIT\" VALUE=\"Create\"> a child object from ", objname, " with the new name of <BR><INPUT TYPE=\"HIDDEN\" NAME=\"action\" VALUE=\"create\"><INPUT NAME=\"name\" SIZE=50><INPUT TYPE=\"HIDDEN\" NAME=\"createobject\" VALUE=\"", tonum(object), "\"></FORM>")};
endif
"";
return info;
"Last modified Fri Aug 16 03:05:39 1996 IDT by EricM (#3264).";
.

@verb #118:"generate_display_list" this none this rxd #95
@program #118:generate_display_list
"Returns an HTML doc containing a list of all kids of args[1],";
"who is each object's owner, and how many child objects exists for each.";
"Each of these is hyperlinked, to an object browse page, the owner's";
"MOO home page, or a 'showkids' hyperlinked list, respectively.";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
objs = args[1];
html = {"<DL COMPACT>"};
item_prefix = "<DT><A HREF=\"&LOCAL_LINK;/objbrowser/browse_or_edit/browse/";
owner_prefix = "<A HREF=\"&LOCAL_LINK;/info/";
showkids_prefix = "<A HREF=\"&LOCAL_LINK;/objbrowser/browse_or_edit/showkids/";
objlist = {};
too_many = 0;
if ((len = length(objs)) > 100)
  too_many = len - 100;
  objs = objs[1..100];
endif
for object in (objs)
  line = tostr(item_prefix, tonum(object), "\"><B>", object.name, "</B></A> [", object, "] ");
  line = line + tostr("<DD>is owned by ", owner_prefix, tonum(object.owner), "/info\">", object.owner.name, "</A>");
  if (kids = length(children(object)))
    line = line + tostr(", and is the parent of ", showkids_prefix, tonum(object), "\">", kids = length(children(object)), (kids == 1) ? " object." | " objects.", "</A>");
  else
    line = line + tostr(", and is the parent of 0 objects.");
  endif
  html = {@html, line};
  if ((seconds_left() < 2) || (ticks_left() < 4000))
    $command_utils:suspend_if_needed(1);
  endif
endfor
html = {@html, @$list_utils:reverse($list_utils:slice($list_utils:sort_alist(objlist, 2)))};
html = {@html, "</DL>"};
if (too_many)
  html = {@html, ("<B>Plus " + tostr(too_many)) + " more....</B><P>"};
endif
return html;
"Last modified Sun Jun 25 07:57:06 1995 IDT by EricM (#3264).";
.

@verb #118:"method_get" this none this rx #95
@program #118:method_get
"Handles web calls that aren't POSTed forms, including object browsing";
"functions like 'browse', 'showkids', 'showhelp', and providing a help";
"doc on pronoun substitutions in messages.";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
if ((caller != this) && (caller != $http_handler))
  return E_PERM;
elseif (length(args) < 3)
  return E_ARGS;
endif
this.web_calls = this.web_calls + 1;
code = this:get_code();
who = args[1];
what = args[2];
action = "";
title = "Object Browser and Editor";
links_back = tostr("<HR><B>[</B><A HREF=\"&LOCAL_LINK;/objbrowser/\">Back to the Object Browser</A>  <B>|</B> ", $web_utils:rtn_to_viewer(), "<B>]</B><HR>");
set_task_perms((player in connected_players()) ? player | $no_one);
footer = {links_back, tostr("User: ", player.name, " (", player, ") - Access: ", $web_utils:access_security()[2])};
if (rest = args[3])
  "extract action from path";
  len = length(rest);
  action = rest[1..(i = index(rest, "/")) ? i - 1 | len];
  rest = (i && (i < len)) ? rest[i + 1..len] | "";
endif
if ((len = length(rest)) && $string_utils:is_numeric(rest[1..(i = index(rest, "/")) ? i - 1 | len]))
  item = toobj(rest[1..(i = index(rest, "/")) ? i - 1 | len]);
  rest = (i && (i < len)) ? rest[i + 1..len] | "";
  title = "Object Browser and Editor - " + (item = toobj(item)):name();
endif
if (!action)
  "no action specified in the path, so return the object selection page";
  return {"Object Browser and Editor - Main Page", {links_back, @this:basic_webedit_form(), @footer}};
elseif (action == "browse")
  "simple object browsing; info on a particular object";
  return {title, {links_back, @this:show_for_web(item), @footer}};
elseif (action == "showkids")
  "generate a list of kids, each a hyperlink to browsing the kid";
  return {title, {links_back, @this:showkids_for_web(item), @footer}};
elseif (action == "showhelp")
  "show the help documentation for the specified object";
  return {title, {links_back, @this:object_help(item), @footer}};
elseif (action == "browse_details")
  "browse verbs and properties on an object";
  return {title, {links_back, @this:browse_details(item), @footer}};
elseif (((action == "browse_verb") && (rest[1..4] == "verb")) && (vrb = rest[5..(i = index(rest, "/")) ? i - 1 | length(rest)]))
  "list the code for a verb";
  return {title, {links_back, @this:browse_verb(item, vrb), @footer}};
elseif (action == "help_pronouns")
  "provide the equivalent to 'help pronouns'";
  help = $code_utils:help_db_search("pronouns", db_list = $code_utils:help_db_list());
  help = help[1]:get_topic(help[2], db_list);
  final_help = {};
  for line in (help)
    final_help = {@final_help, @$player:linesplit(line, 75)};
  endfor
  return {title, {links_back, "<H2>About Pronoun Substitution in Object Messages</H2>", "<PRE>", @final_help, "</PRE>", @footer}};
else
  "should never get here";
  return {"Object Browser and Editor", {"<H2>Oops!</H2>", "Sorry but some sort of error seems to have occurred. Please let the owner of the object you're working with know about it.", @footer}};
endif
"Last modified Thu Sep 14 11:06:16 1995 IDT by EricM (#3264).";
.

@verb #118:"method_post" this none this rx #95
@program #118:method_post
"method_post(who, what OBJ, rest OBJ, search STR, form STR) -> HTML frg LIST";
"Handles all POSTed HTML forms for the object browser/editor.";
"Uses a hidden form variable named 'action' to determine what sort of";
"posting it is and how to respond.  Defined actions are:";
"  do_edit_object = accept, process, and act on a form containing edits of an objects basic caracteristics";
"  do_advanced_edit = accept, process, and act on a form containing raw property edits";
"  do_verb_edit = reserved for processing a form that specifies verb editing";
"  do_property_edit = reserved for processing a form specifying property edits";
"  browse = request to browse an object's characteristics";
"  edit_object =  request for basic form for editing an object's basic characteristics";
"  advanced_edit = request for raw editing of all owned object properties";
"  verb_edit = defined, but not written yet; will handle verb editing";
"  property_edit = reserved for requests for a form for property editing";
"  create = create an object";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
if ((caller != this) && (caller != $http_handler))
  return E_PERM;
endif
this.web_calls = this.web_calls + 1;
who = args[1];
what = args[2];
rest = args[3];
search = args[4];
form = $web_utils:parse_form(args[5], 2);
field_names = form[1];
field_values = form[2];
item = "";
changes_made = {};
links_back = tostr("<HR><B>[</B><A HREF=\"&LOCAL_LINK;/objbrowser/\">to the Object Browser's menu page</A> <B>|</B> ", $web_utils:rtn_to_viewer(), "<B>]</B><HR>");
"Only connected users have full access up to their MOO perms";
set_task_perms(perms = (player in connected_players()) ? player | $no_one);
footer = {links_back, tostr("User: ", player.name, " (", player, ") - Access:", $web_utils:access_security()[2])};
"There should ALWAYS be a variable named 'action' defined when this verb is called,";
"  so the next line should always be true.";
if ((i = "action" in field_names) && (action = field_values[i]))
  "first test if this is just an object being selected from the basic web browser/editor page...";
  "if so, either nearby_objs, owned_objs, or objnumber should be defined...";
  if ((i = "nearby_objs" in field_names) && (item = field_values[i]))
  elseif ((i = "owned_objs" in field_names) && (item = field_values[i]))
  elseif ((i = "objnumber" in field_names) && (item = field_values[i]))
  elseif (($recycler:valid(what) && $recycler:valid(generic = toobj(rest))) && (action == "do_edit_object"))
    "Someone submitted an object editing form. Do the edit, and send them a fresh form...";
    if (!(player in connected_players()))
      changes_made = {"<B>Only connected users can edit objects; No changes made.</B><P>"};
    elseif (!(result = generic:edit_object_by_web(what, field_names, field_values)))
      "the object looked over the form but didn't find any changes to be made...";
      changes_made = {"<B>No changes requested; none made.</B><P>"};
    elseif (result == 1)
      "Changes made and no error occurred...";
      changes_made = {("<B>Changes saved " + ctime()) + "</B><P>"};
    else
      "Some kind of error was returned...";
      changes_made = {tostr("<B>No changes made: ", result, "</B><P>")};
    endif
    "Setup item and action to have fresh object editting form sent back...";
    item = tostr(tonum(what));
    action = "edit_object";
  elseif ($recycler:valid(what) && (action == "do_advanced_edit"))
    "Someone submitted a raw property editting form. Do the edit, and send a fresh form...";
    if (!(player in connected_players()))
      changes_made = {"<B>Only connected users can edit objects; No changes made.</B><P>"};
    elseif (!(result = this:do_prop_edit(what, field_names, field_values)))
      changes_made = {"<B>No changes requested; none made.</B><P>"};
    elseif (result == 1)
      changes_made = {("<B>Changes saved " + ctime()) + "</B><P>"};
    else
      changes_made = {("<B>No changes made: " + result) + "</B><P>"};
    endif
    item = tostr(tonum(what));
    action = "advanced_edit";
  elseif (((action == "create") && (perms != $no_one)) && $recycler:valid(item = toobj(field_values["createobject" in field_names])))
    "User requested child of 'item' be created";
    if (!match(namestr = field_values["name" in field_names], "%w"))
      changes_made = {"<B>Object not created: No name given</B><P>"};
      action = "browse";
      item = tostr(tonum(item));
    elseif (OBJ != typeof(result = perms:_create(item)))
      changes_made = {tostr("<B>Object not created: ", result, "</B>")};
      action = "browse";
      item = tostr(tonum(item));
    else
      $building_utils:set_names(result, namestr);
      move(result, perms);
      changes_made = {tostr("<B>Created object ", result:namec(), " (", result, ") from parent ", (p = parent(result)):namec(), " (", p, ")", (aliases = setremove(result.aliases, result.name)) ? " and with aliases: " + $string_utils:english_list(aliases) | "", "</B>")};
      action = "edit_object";
      item = tostr(tonum(result));
    endif
  endif
  "";
  "**** Generate HTML form  ****";
  "";
  if (((!item) || (!$string_utils:is_numeric(item = strsub(item, "#", "")))) || (!$recycler:valid(item = toobj(item))))
    if (((item[1] == "$") && ((item = item[2..length(item)]) in properties(#0))) && (typeof(val = #0.(item)) == OBJ))
      "it's a core pointer";
      item = tostr(val);
    else
      return {this.name, {links_back, "<H2>The Object Browser and Editor</H2>", "Sorry, but you didn't select a valid object to browse.  Please <A HREF=\"&LOCAL_LINK;/objbrowser/\">return to the object browser form</A> and select an object."}};
    endif
  endif
  if (action == "browse")
    return {(this.name + " - ") + (item = toobj(item)):name(), {links_back, "<H2>Object Browser and Editor - Browse</H2>", @changes_made, @this:show_for_web(item), @footer}};
  elseif (action == "edit_object")
    "** User Requested Complete Basic Object Characteristics Editing Form **";
    if ($recycler:valid(item = toobj(item)) && (!$perm_utils:controls(player, item)))
      return {(this.name + " - ") + item.name, {links_back, "<H2>Object Browser and Editor - Edit Basic Characteristics</H2>", tostr("Sorry, but only this object's owner (", item.owner:name(), ") can edit ", item:name(1), " (", item, ")."), @footer}};
    elseif (is_player(item = toobj(item)))
      return {(this.name + " - ") + item.name, {"<HR><HR><H2>Object Browser and Editor - Edit Basic Characteristics</H2>", "Sorry, but this editor isn't for editing people's characters.  You can use the <A HREF=\"&LOCAL_LINK;/char\">Character Customizer</A> for that, though.", @footer}};
    endif
    "Create and send complete form for editing basic object characteristics";
    form = {links_back, "<A NAME=\"PageTop\"><H2>Object Browser and Editor - Edit Basic Characteristics</H2></A>", @changes_made, "<BR>"};
    objectform = this:build_basicchar_form(item);
    return {tostr(this.name, " - ", item.name), {@form, "Go to section for characteristics associated with:<UL>", @objectform[1], "</UL>", @objectform[2], "<P><A HREF=\"#PageTop\">[ to Top of Page ]</A><BR>", @footer}};
    "";
  elseif (action == "advanced_edit")
    "** User wants to edit all properties on the object s/he owns **";
    if ($recycler:valid(item = toobj(item)) && (!$perm_utils:controls(player, item)))
      return {(this.name + " - ") + item.name, {links_back, "<H2>Object Browser and Editor - Edit Basic Characteristics</H2>", tostr("Sorry, but only this object's owner (", item.owner:name(), ") can edit ", item:name(1), " (", item, ")."), @footer}};
    else
      return {tostr(this.name, " - ", item.name, " (adv)"), {links_back, "<H2>Object Browser and Editor - Advanced Object Property Editing</H2>", @changes_made, @this:edit_raw_props(item), @footer}};
    endif
  elseif (action == "verb_edit")
    return {this.name, {links_back, "<H2>Object Browser and Editor</H2>", "Sorry, but only browsing is available at this time.", @footer}};
  endif
endif
return {this.name, {links_back, "<H2>Object Browser and Editor</H2>", "Sorry, but the object and/or action you selected appears to be broken.  Please let the administrators know, and tell them exactly what you were doing when the error happened so they can fix this problem."}};
"Last modified Mon Aug 26 16:45:25 1996 IDT by EricM (#3264).";
.

@verb #118:"basic_webedit_form" this none this rx #95
@program #118:basic_webedit_form
"basic_webedit_form() -> LIST";
"Generates the object and action selection page for the object browser";
"and editor.";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
if (caller != this)
  return E_PERM;
endif
"the header section...";
form = {"<H2>Object Browser and Editor - Main Page</H2>"};
form = {@form, "<FORM METHOD=POST ACTION=\"objbrowser\">"};
form = {@form, "<P><INPUT TYPE=\"SUBMIT\" VALUE=\"Do Browse or Edit\">"};
form = {@form, "<INPUT TYPE=\"RESET\" VALUE=\"Clear all selections on this page\">"};
"";
"section to specify what action you wish to take with the selected object";
form = {@form, "<H3>Select an action</H3>"};
form = {@form, "<DL><DL><DT><INPUT TYPE=\"RADIO\" NAME=\"action\" VALUE=\"browse\" CHECKED>Browse an object's characteristics"};
if (((player in connected_players()) && $object_utils:isa(player, $builder)) && player.owned_objects)
  "Don't allow object editing unless the person is connected via telnet";
  "also, is a builder, and owns some objects";
  form = {@form, "<DT><INPUT TYPE=\"RADIO\" NAME=\"action\" VALUE=\"edit_object\">Edit an object's basic characteristics (including its name, aliases, description, and URL or HTML document)"};
  form = {@form, "<DT><INPUT TYPE=\"RADIO\" NAME=\"action\" VALUE=\"advanced_edit\">Raw editing of object properties (for advanced users)"};
  if (0 && player.programmer)
    "programmer's features are currently disabled...and not yet written";
    form = {@form, "<DT><INPUT TYPE=\"RADIO\" NAME=\"action\" VALUE=\"verb_edit\">Programmer's web editing interface (not working yet)"};
  endif
else
  if (player == $no_one)
    form = {@form, tostr("<P>Your access is: anonymous and not confirmed by telnet/client connection<BR>")};
  elseif (!(player in connected_players()))
    form = {@form, "<P>Your access is: not confirmed by telnet/client connection<BR>"};
  elseif (!player.owned_objects)
    form = {@form, "<P>You don't own any objects to edit.<BR>"};
  endif
  form = {@form, "Only browsing is permitted."};
endif
form = {@form, "</DL></DL>"};
"";
"the object selection section...";
form = {@form, "<H3>Select an object to browse or edit</H3>"};
"the list of nearby objects...";
nearby_objs = {@player:contents()};
if ($recycler:valid(player.location) && (player.location != $limbo))
  nearby_objs = {player.location, @nearby_objs, @$object_utils:isa(player.location, $generic_editor) ? {} | player.location:contents()};
endif
form = {@form, "<UL>"};
if (nearby_objs)
  form = {@form, "<LI><B>From objects near you:</B>"};
  form = {@form, "<SELECT NAME=\"nearby_objs\" SIZE=5>"};
  for item in (nearby_objs)
    form = {@form, (("<OPTION VALUE=\"" + tostr(tonum(item))) + "\">") + item:name(0)};
    if ((seconds_left() < 2) || (ticks_left() < 4000))
      suspend(1);
    endif
  endfor
  form = {@form, "</SELECT><P>"};
endif
"the list of owned objects...";
if (owned_objs = player.owned_objects)
  form = {@form, "<LI><B>From objects you own</B>"};
  form = {@form, "<SELECT NAME=\"owned_objs\" SIZE=5>"};
  while (owned_objs)
    line = "";
    for i in [1..10]
      if (owned_objs)
        line = tostr(line, " ", "<OPTION VALUE=\"", tonum(owned_objs[1]), "\">", owned_objs[1]:name(0) || owned_objs[1].name);
        owned_objs = listdelete(owned_objs, 1);
      endif
    endfor
    form = {@form, line};
    ((seconds_left() < 2) || (ticks_left() < 4000)) ? suspend(1) | 0;
  endwhile
  form = {@form, "</SELECT><P>"};
endif
"a field for entering the object number directly...";
form = {@form, tostr("<LI><B>By object number or core pointer name</B> (max. ", max_object(), ") <INPUT NAME=\"objnumber\"></UL>")};
"";
"add some footer info to the page and return it";
form = {@form, "<P><INPUT TYPE=\"SUBMIT\" VALUE=\"Do Browse or Edit\">"};
form = {@form, "<INPUT TYPE=\"RESET\" VALUE=\"Clear all selections on this page\">"};
form = {@form, "</FORM>"};
return form;
"Last modified Fri Aug 16 02:54:11 1996 IDT by EricM (#3264).";
.

@verb #118:"get_verbs_for_web" this none this rx #95
@program #118:get_verbs_for_web
"get_verbs_for_web(what OBJ) -> LIST";
"Returns a list of strings suitable for inclusion into an HTML doc,";
"listing the verbs one would see on 'what' with an 'examine' command.";
"Basically copied from #1:examine_verbs with some mods for HTML formatting";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
who = caller_perms();
what = args[1];
name = what.name;
vrbs = {};
commands_ok = "";
dull_classes = {$root_class, $room, $player, $prog, $builder};
hidden_verbs = what:hidden_verbs(who);
set_task_perms(who);
while (what != $nothing)
  if ((seconds_left() < 2) || (ticks_left() < 4000))
    suspend(1);
  endif
  "Note that the next line expects this verb to be !d to test caller's permissions to read object";
  if ((!(what in dull_classes)) && (verbs = length(verbs(what))))
    for i in [1..verbs]
      if ((seconds_left() < 2) || (ticks_left() < 4000))
        suspend(1);
      endif
      if (!(info = `verb_info(what, i) ! E_PERM'))
        "no perms to read that verb";
        continue i;
      endif
      syntax = verb_args(what, i);
      if (this:examine_verb_ok(what, i, info, syntax, commands_ok, hidden_verbs))
        dobj = syntax[1];
        prep = syntax[2];
        iobj = syntax[3];
        if (syntax == {"any", "any", "any"})
          prep = "none";
        endif
        if (prep != "none")
          for x in ($string_utils:explode(prep, "/"))
            if (length(x) <= length(prep))
              prep = x;
            endif
          endfor
        endif
        "This is the correct way to handle verbs ending in *";
        vname = info[3];
        while (i = index(vname, "* "))
          vname = tostr(vname[1..i - 1], "<anything>", vname[i + 1..length(vname)]);
        endwhile
        if (vname[i = length(vname)] == "*")
          vname = vname[1..i - 1] + "<anything>";
        endif
        vname = strsub(vname, " ", "/");
        rest = "";
        if (prep != "none")
          rest = " " + ((prep == "any") ? "<anything>" | prep);
          if (iobj != "none")
            rest = tostr(rest, " ", (iobj == "this") ? name | "<anything>");
          endif
        endif
        if (dobj != "none")
          rest = tostr(" ", (dobj == "this") ? name | "<anything>", rest);
        endif
        vrbs = setadd(vrbs, ("  " + vname) + rest);
      endif
    endfor
  endif
  what = parent(what);
endwhile
if ($code_utils:verb_or_property(what, "help_msg"))
  vrbs = {@vrbs, tostr("  help ", dobjstr)};
endif
return $web_utils:html_entity_sub(vrbs);
"Last modified Thu Oct 17 19:17:14 1996 IST by EricM (#3264).";
.

@verb #118:"object_help" this none this rx #95
@program #118:object_help
"object_help(what OBJ) -> LIST";
"Returns a hyperlinked line presenting a link to the help text for";
"'what' as a list of strings to be incorporated into an HTML page";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
if (caller != this)
  return E_PERM;
endif
item = args[1];
text = {tostr("<H2>Help text for <A HREF=\"&LOCAL_LINK;/objbrowser/browse_or_edit/browse/", tonum(item), "\">", item:name(1), "</A></H2>")};
if (typeof(help_msg = item:help_msg()) in {STR, LIST})
elseif (typeof(help_msg = item.help_msg) in {STR, LIST})
else
  help_msg = {"Sorry, there appear to be no help text available for this object."};
endif
help_msg = (typeof(help_msg) == LIST) ? help_msg | {help_msg};
text = {@text, "<PRE>", @$web_utils:html_entity_sub(help_msg), "</PRE>"};
return text;
"Last modified Thu Aug 24 03:32:13 1995 IDT by EricM (#3264).";
.

@verb #118:"edit_raw_props" this none this rxd #95
@program #118:edit_raw_props
"Generate the web form for doing a raw property edit of all owned props";
"Creates a set of HTML form fields for each one with:";
"  changeprop_<prop> = checkbox indicating the property should be changed";
"  clear_prop_<prop> = clear this property";
"  proptype_<prop> = value type; the integer associated with NUM, OBJ, etc.";
"  prop_value_<prop> = the value of the property";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
what = args[1];
if (!$perm_utils:controls(who = caller_perms(), what))
  return E_PERM;
endif
"generate the page's header info";
form = {tostr("<HR><H3>Editing: ", what:namec(1), " (", what, ")</H3><HR>")};
form = {@form, "<B>Warning</B> - Don't use this form unless you're pretty sure you know what you're doing. Some brief <A HREF=\"#instructions\">instructions</A> can be found at the end of this page."};
form = {@form, tostr("<FORM METHOD=POST ACTION=\"&LOCAL_LINK;/", this:get_code(), "/", tonum(what), "\">")};
form = {@form, "<INPUT TYPE=\"SUBMIT\" VALUE=\"Update Owned Properties\"><INPUT TYPE=\"RESET\" VALUE=\"Clear changes to this form\"><P>"};
form = {@form, "<INPUT TYPE=\"HIDDEN\" NAME=\"action\" VALUE=\"do_advanced_edit\">"};
form = {@form, "<HR><DL>"};
"";
props = $object_utils:owned_properties(what, who.wizard ? what.owner | who);
"generate the form's section for each owned property";
for prop in (props)
  "the checkbox to indicate the prop value should be changed";
  line = tostr("<DT><INPUT TYPE=\"CHECKBOX\" NAME=\"changeprop_", prop, "\"><B>", prop, "</B> - clear:<INPUT TYPE=\"CHECKBOX\" NAME=\"clear_prop_", prop, "\"", is_clear_property(what, prop) ? " CHECKED" | "", ">");
  "a section of radio buttons to indicate the prop value's type";
  line = line + tostr(" Type: <INPUT TYPE=\"RADIO\" NAME=\"proptype_", prop, "\" VALUE=\"", NUM, "\"", ((type = typeof(value = what.(prop))) == NUM) ? "CHECKED" | "", "> number, ");
  line = line + tostr("<INPUT TYPE=\"RADIO\" NAME=\"proptype_", prop, "\" VALUE=\"", OBJ, "\"", (type == OBJ) ? "CHECKED" | "", "> object, ");
  line = line + tostr("<INPUT TYPE=\"RADIO\" NAME=\"proptype_", prop, "\" VALUE=\"", STR, "\"", (type == STR) ? "CHECKED" | "", "> string, ");
  line = line + tostr("<INPUT TYPE=\"RADIO\" NAME=\"proptype_", prop, "\" VALUE=\"", LIST, "\"", (type == LIST) ? "CHECKED" | "", "> list, ");
  line = line + tostr("<INPUT TYPE=\"RADIO\" NAME=\"proptype_", prop, "\" VALUE=\"", ERR, "\"", (type == ERR) ? "CHECKED" | "", "> error ");
  form = {@form, line};
  "a special section to handle values that are lists";
  if (typeof(value) == LIST)
    "send the value to this:from_list to process it and determine what form";
    "the data entry field for this prop should be in";
    if (typeof((value = this:from_list(value))[1]) == ERR)
      "the value is anything but a list of strings; a complex list";
      "maybe someone will figure out a good way to handle these in an HTML form";
      form = {@form, "<DD> This value is a complex list, and can't be edited here.<P>"};
    elseif (value[1])
      "the value is best presented as a TEXTAREA";
      form = {@form, tostr("<DD><TEXTAREA NAME=\"", "prop_value_", prop, "\" ROWS=4 COLS=70>"), @value[2], "</TEXTAREA><P>"};
    else
      "the list is best presented as a comma-deliminated set of string values";
      form = {@form, tostr("<DD><INPUT NAME=\"", "prop_value_", prop, "\" SIZE=60 VALUE=\"", value[2], "\"><P>")};
    endif
  else
    "everything other than lists can just use an ordinary INPUT field";
    "for the user to edit the value";
    form = {@form, tostr("<DD><INPUT NAME=\"", "prop_value_", prop, "\" SIZE=60 VALUE=\"", value, "\"><P>")};
  endif
  if ((seconds_left() < 2) || (ticks_left() < 4000))
    suspend(1);
  endif
endfor
"";
"add some page footer info and return the completed form";
form = {@form, "</DL><INPUT TYPE=\"SUBMIT\" VALUE=\"Update Owned Properties\"><INPUT TYPE=\"RESET\" VALUE=\"Clear changes to this form\"><P></FORM>"};
form = {@form, "<A NAME=\"instructions\"><HR></A>", @this.raw_prop_edit_instructions, "<P>"};
return form;
"Last modified Mon Aug 26 06:16:01 1996 IDT by EricM (#3264).";
.

@verb #118:"do_prop_edit" this none this rxd #95
@program #118:do_prop_edit
"do_prop_edit(what OBJ, fieldnames LIST, fieldvalues LIST) -> NUM or STR";
"  Processes a form describing object properties (on 'what') to be";
"changed, determining which need to be changed, what to change them";
"to, and performing the changes.";
"The fieldnames and fieldvalue lists are linked.";
"  Goes through the fieldnames looking for ones with the prefix";
"'changeprop_' and uses the remainder of the fieldname to determine";
"the name of the field to be edited.";
"  If a field 'clear_prop_<prop>' exists, then the property is set";
"clear irregardless of any other information given.";
"  Then the value of 'proptype_<prop>' is used to determine the";
"value type of the new value, and 'prop_value_<prop>' specifies";
"the new property value.";
"  If any new values are given which can't be used given the value type";
"specified, reject all the changes besides requests to clear properties,";
"returning a message specifying which property couldn't be changed.";
"This is to obviate the need for complex error messages like 'such and";
"such was updated, but so and so was specified with an illegal value'.";
"There's probably a better way to do this, but it doesn't hurt since";
"people are just going to go back a page on their browser, correct";
"the error, and resubmit the form.";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
if ((caller != this) || (!$perm_utils:controls(caller_perms(), what = args[1])))
  return E_PERM;
endif
fieldnames = args[2];
fieldvalues = args[3];
changelist = {};
result = 0;
"scan through fields for ones beginning with 'changeprop_'";
while ((typeof(result) == NUM) && (index = $string_utils:find_prefix("changeprop_", fieldnames)))
  "got one, so extract all the relevent associated fields...";
  prop = strsub(fieldnames[index], "changeprop_", "");
  type = tonum(fieldvalues[("proptype_" + prop) in fieldnames]);
  clear = ("clear_prop_" + prop) in fieldnames;
  value = (i = ("prop_value_" + prop) in fieldnames) ? fieldvalues[i] | E_NONE;
  if (clear)
    "prop to be set clear, so do it and ignore other associated fields";
    clear_property(what, prop);
    result = 1;
  else
    "property to be set to a specified value, so figure out what value type,";
    "  determine if the fieldvalue can be made to fit that type, and";
    "  either change the value or return an error.";
    value = (typeof(value) == STR) ? $string_utils:trim(value) | value;
    if ((type != LIST) && (typeof(value) == LIST))
      "Preprocess the special situation where the fieldvalue is a list (ie.";
      "the input from a <TEXTAREA>, but the specified value type is not";
      "a list.  This saves repeating this code in every subsection below.";
      newvalue = this:to_value(type, value);
      value = newvalue[2];
      if (newvalue[1] == E_INVARG)
        result = tostr("Can't set ", {"numeric", "object number", "string", "error", "list"}[type + 1], " value for property \"", prop, "\" to the value you gave.");
        type = newvalue[1];
      endif
    endif
    "Finally, move on to the main part: determining the value type and";
    "processing the fieldvalue appropriately into that type.";
    if (type == LIST)
      if (typeof(value) == LIST)
        result = 1;
      else
        if ((result = this:to_value(type, value))[1] == E_INVARG)
          result = tostr("Can't set ", {"numeric", "object number", "string", "error", "list"}[type + 1], " value for property \"", prop, "\" to the value you gave.");
        else
          value = result[2];
          result = 1;
        endif
      endif
    elseif (type == NUM)
      if ((typeof(value) == NUM) || $string_utils:is_numeric(value))
        value = tonum(value);
        result = 1;
      else
        result = tostr("Can't set numeric value of property \"", prop, "\" to \"", value, "\"");
        value = what.(prop);
      endif
    elseif (type == STR)
      value = tostr(value);
      result = 1;
    elseif (type == OBJ)
      if ((typeof(value) == OBJ) || $string_utils:is_numeric(strsub(value, "#", "")))
        value = toobj(value);
        result = 1;
      elseif (1 == index(value, "$"))
        "deal with the special case where an object number is being set by";
        "reference to a prop on #0 via the '$' convention";
        if ((pointer = strsub(value, "$", "")) in properties(#0))
          value = #0.(pointer);
          result = 1;
        else
          result = ((("No such pointer named \"$" + pointer) + "\" to set property \"") + prop) + "\" to.";
          value = what.(prop);
        endif
      else
        result = tostr("Can't set object number value of property \"", prop, "\" to \"", value, "\"");
        value = what.(prop);
      endif
    elseif (type == ERR)
      if (typeof(value) == ERR)
        result = 1;
      elseif (i = value in $code_utils.error_names)
        value = $error.all_errors[i];
        result = 1;
      else
        result = ((("Can't set error value of property  \"" + prop) + "\" to \"") + value) + "\"";
        value = what.(prop);
      endif
    endif
    "if a valid value for the type specified could be determined,";
    "add it to the list of property value changes to be made after";
    "all the form is processed and appropriate values are cleared";
    if (result == 1)
      changelist = {@changelist, {prop, value}};
    endif
  endif
  "remove the field that's been processed so we can move on to the next";
  fieldnames = listdelete(fieldnames, index);
  fieldvalues = listdelete(fieldvalues, index);
  if ((seconds_left() < 2) || (ticks_left() < 4000))
    suspend(1);
  endif
endwhile
if ((result == 1) && changelist)
  "go through the list of properties to be changed, and do each";
  for change in (changelist)
    what.(change[1]) = change[2];
  endfor
endif
return result;
"Last modified Sun Jul  7 05:08:12 1996 IDT by EricM (#3264).";
.

@verb #118:"from_list" this none this rxd #95
@program #118:from_list
"Take a LIST and return either {0, STR} or {1, LIST of strings}";
"  or {E_INVARG} if the list is complex (list with sublists)";
"This verb is used to format a list of strings into a form useful";
"  for including on a web form.  If the args[1] can be represented";
"  easily as a comma-delimeted string, it generates that.  If that";
"  would be too long to fit on one line, it instead converts args[1]";
"  into a list of strings, suitable for a <TEXTAREA> field.";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
listval = args[1];
stringlist = {};
complex = 0;
while ((!complex) && listval)
  if (typeof(listval[1]) != STR)
    complex = 1;
  else
    stringlist = {@stringlist, listval[1]};
    listval = listdelete(listval, 1);
  endif
endwhile
if (!complex)
  if (length(tostr(@stringlist)) < 70)
    result = {0, $string_utils:from_list(stringlist, ", ")};
  else
    result = {1, stringlist};
  endif
else
  result = {E_INVARG};
endif
return result;
"Last modified Sun Jun 25 06:01:34 1995 IDT by EricM (#3264).";
.

@verb #118:"to_value" this none this rxd #95
@program #118:to_value
"to_value(argtype NUM, value LIST or STR)  -> {type or E_INVARG, value}";
"Takes a form field value and generates the corresponding MOO value";
"The argtype is the number associated with LIST, STR, NUM, ....";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
type = args[1];
fromvalue = args[2];
tovalue = E_NONE;
error = 0;
if (type == LIST)
  if (typeof(fromvalue) == LIST)
    tovalue = fromvalue;
  else
    tovalue = $list_utils:map_arg($string_utils, "trim", $string_utils:explode(fromvalue, ","));
  endif
elseif (typeof(fromvalue) == LIST)
  if ((length(fromvalue) > 1) && $string_utils:trim(tostr(@$list_utils:flatten(fromvalue[2..length(fromvalue)]))))
    type = E_INVARG;
  else
    fromvalue = fromvalue[1];
  endif
endif
if (!(type in {LIST, E_INVARG}))
  if (type == STR)
    tovalue = fromvalue;
  elseif (type == NUM)
    if ($string_utils:is_numeric(fromvalue))
      tovalue = tonum(fromvalue);
    else
      type = E_INVARG;
    endif
  elseif (type == OBJ)
    if ($string_utils:is_numeric(fromvalue = strsub(fromvalue, "#", "")))
      tovalue = toobj(fromvalue);
    else
      type = E_INVARG;
    endif
  elseif (type == ERR)
    if (i = fromvalue in $code_utils.error_names)
      tovalue = $error.all_errors[i];
    else
      type = E_INVARG;
    endif
  endif
endif
return {type, tovalue};
"Last modified Sun Jul  7 05:09:38 1996 IDT by EricM (#3264).";
.

@verb #118:"browse_details" this none this rx #95
@program #118:browse_details
"Provides basic property and verb information";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
if (caller != this)
  return E_PERM;
endif
item = args[1];
code = this:get_code();
text = {tostr("<H2> <A HREF=\"#prop\">Property</A> and <A HREF=\"#verb\">Verb</A> <A NAME=\"top\">Summary</A> for <A HREF=\"&LOCAL_LINK;/", code, "/browse_or_edit/browse/", tonum(item), "\">", item:name(1), "</A> (", item, ")</H2>")};
perms = (valid(perms = caller_perms()) && is_player(perms)) ? perms | $no_one;
perms = (perms in connected_players()) ? perms | $no_one;
"Strip perms if user isn't connected";
set_task_perms(perms);
"";
text = {@text, "<H3><A NAME=\"prop\">Properties</A></H3>"};
"";
"sort through all properties and pick out ones defined on the obj, and ones inherited but with an altered value";
if (item.r || $perm_utils:controls(perms, item))
  findable = $object_utils:findable_properties(item);
  "note that if perms are insuffienct for properties(), no props will be displayed";
  props = properties(item) || {};
  findtext = proptext = {};
  for prop in (findable)
    if ((onobj = prop in props) || (!is_clear_property(item, prop)))
      propinfo = tostr(" [", (info = property_info(item, prop))[1].name, " ", info[1], ", ", info[2] ? info[2] | "- ", "]");
      "if info[1] is an ERR, there was a perms failure";
      propinfo = (typeof(info[1]) == ERR) ? "[ - ]" | propinfo;
      if (typeof(val = item.(prop)) == STR)
        val = ("\"" + val) + "\"";
      elseif (typeof(val) == LIST)
        val = $string_utils:print_suspended(val);
      else
        val = tostr(val);
      endif
      if (onobj)
        proptext = {@proptext, tostr("<LI><B>", prop, "</B>", propinfo, " = ", $web_utils:html_entity_sub(val, 1))};
      else
        findtext = {@findtext, tostr("<LI><B>", prop, "</B>", propinfo, " = ", $web_utils:html_entity_sub(val, 1))};
      endif
    endif
    ((seconds_left() < 2) || (ticks_left() < 4000)) ? suspend(1) | 0;
  endfor
endif
proptext = proptext ? {"<UL>", @proptext, "</UL>"} | {"<UL><LI>none</UL>"};
findtext = findtext ? {"<UL>", @findtext, "</UL>"} | {"<UL><LI>none</UL>"};
text = {@text, "Properties defined on the object itself:", @proptext, "Inherited properties with non-default values:", @findtext};
text = {@text, "<A HREF=\"#top\">To top of page</A>"};
"";
text = {@text, "<HR><H3><A NAME=\"verb\">Verbs</A></H3>"};
"";
text = {@text, "Verbs defined on the object itself:<P>"};
"note that if perms are insufficient for verbs(), no verbs are displayed";
verbs = verbs(item) || {};
vrbtext = {};
prefix = tostr("<A HREF=\"&LOCAL_LINK;/", code, "/browse_or_edit/browse_verb/", tonum(item), "/verb");
for vrb in [1..length(verbs)]
  "check if an ancestor carries a verb of the same name";
  covered = (has_verb = $object_utils:has_verb(parent(item), verbs[vrb])) ? tostr(" (also defined on ancestor \"", has_verb[1].name, "\", ", has_verb[1], ")") | "";
  vrbperms = tostr(" [", (info = verb_info(item, vrb))[1].name, " ", info[1], ", ", info[2] ? info[2] | " - ", "]");
  if (typeof(info[1]) != ERR)
    "Don't show the verb if perms were insufficient";
    vrbargs = verb_args(item, vrb);
    vrbargstr = tostr(" &lt;", vrbargs[1], " ", $code_utils:short_prep(vrbargs[2]) || "none", " ", vrbargs[3], "&gt; ");
    vrbtext = {@vrbtext, tostr("<DT><B>", prefix, vrb, "\">", verbs[vrb], "</A> ", vrbperms, vrbargstr, "</B>", covered)};
    if (vrbdoc = (typeof(vrbdoc = $code_utils:verb_documentation(item, vrb)) == STR) ? {vrbdoc} | vrbdoc)
      vrbdoc = $web_utils:insert_line_tag($web_utils:html_entity_sub(vrbdoc), "<DD>");
      vrbtext = {@vrbtext, @vrbdoc};
    endif
  endif
  ((seconds_left() < 2) || (ticks_left() < 4000)) ? suspend(1) | 0;
endfor
text = {@text, "<DL><DL>", @vrbtext || {"<DT>(none defined)"}, "</DL></DL>"};
"add footer and send text out";
text = {@text, "<A HREF=\"#top\">To top of page</A>"};
return text;
"Last modified Wed Aug 21 00:01:18 1996 IDT by EricM (#3264).";
.

@verb #118:"browse_verb" this none this rxd #95
@program #118:browse_verb
"returns verb code";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
if (caller != this)
  return E_PERM;
endif
item = args[1];
vrb = args[2];
if (((!(vrb = $string_utils:is_integer(vrb) && tonum(vrb))) || (vrb < 1)) || (vrb > length(verbs(item))))
  return {"Sorry, that verb doesn't appear to exist."};
endif
footer = tostr("<A HREF=\"&LOCAL_LINK;/", this:get_code(), "/browse_or_edit/browse_details/", tonum(item), "\">Browse properties and verbs for this object</A>");
text = {tostr("<H2>Code Listing for ", item.name, " (", item, "):", (info = verb_info(item, vrb))[3], "</H2>")};
"check perms";
if (!(index(info[2], "r") || $perm_utils:controls(caller_perms(), info[1])))
  return {@text, "Sorry, you don't have access to this verb's code.<P>", footer};
endif
"write up heading line";
vargs = verb_args(item, vrb);
if (index(vargs[2], "/"))
  vargs[2] = tostr("(", vargs[2], ")");
endif
text = {@text, tostr("<B>", item, ":", $string_utils:print(info[3]), "   ", $string_utils:from_list(vargs, " "), "   ", info[2], "   ", info[1], "</B><P>")};
"make sure the verb has some code";
if (!(code = verb_code(item, vrb)))
  return {@text, "This verb is not yet programmed.<P>", footer};
endif
"return heading with preformatted code";
return {@text, "<PRE>", @$web_utils:html_entity_sub(code), "</PRE>", footer};
"Last modified Tue Aug 20 22:12:03 1996 IDT by EricM (#3264).";
.

@verb #118:"get_code" this none this rxd #95
@program #118:get_code
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
return this.code;
"Last modified Fri Aug  4 06:10:45 1995 IDT by EricM (#3264).";
.

@verb #118:"build_basicchar_form" this none this rxd #95
@program #118:build_basicchar_form
"build_basicchar_form(item OBJ) -> html doc frg LIST";
"Build the basic characteristics editing form for 'item' including";
"sections for each ancestor that can provide one";
"(C) Copyright 1996 BioGate Partners; All rights reserved.";
if (0 && (caller != this))
  return E_PERM;
endif
item = args[1];
linklist = {};
form = {};
toplink = "<A HREF=\"#PageTop\">[ to Top of page ]</A><BR>";
for object in ({item, @$object_utils:ancestors(item)})
  if ("object_edit_for_web" in verbs(object))
    objectform = object:object_edit_for_web(item);
    generic = $string_utils:capitalize($string_utils:nn(object));
    if ((length(objectform) == 2) && (typeof(objectform[2]) == LIST))
      "object's returned {top-name-tag STR, edit-form LIST}";
      linklist = {@linklist, tostr("<LI><A HREF=\"#", objectform[1], "\">", generic, "</A>")};
      form = {@form, "<HR><HR>" + toplink, @objectform[2]};
    elseif ((typeof(objectform[1]) == STR) && (typeof(objectform[2]) == STR))
      "object's returned an html frg w/o a name-tag for top";
      linklist = {@linklist, "<LI>" + generic};
      form = {@form, @objectform};
    endif
  endif
endfor
return {linklist, form};
"Last modified Mon Aug 26 04:52:35 1996 IDT by EricM (#3264).";
.

"***finished***
